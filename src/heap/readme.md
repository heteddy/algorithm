# 最大堆 最小堆

给定一个slice，下标index从0开始，那么index的child节点为 2*index+1 和2* index+ 2；

最大堆实现：
从最后一个父节点(包含叶子节点)开始，逐步向前 运行调整过程(如下步骤)

   + 找到child 节点的索引 2*index+1
   + 比较child节点的兄弟节点，默认找到兄弟中最大的一个作为child index
   + 比较childIndex和index的值，如果childIndex比较大则交换
   + 继续调整childIndex的子节点，如果有的话
   
   
# Top K问题

问题描述：有 N 个数,求出其中的前K个最大的数（又被称作topK问题）

### 解题思路：
  
最大的k个数，用 **最小堆** 来保存；是不是很奇怪，前K个最大的数，为什么是最小堆(小顶堆)呢？

> 因为最小堆，最小的元素在最上面，给定一个元素之后直接比较当前的元素的值和堆顶元素值，大于则替换；这样堆中一直保持着最大的k个数，而且堆的顶端是最小的元素

```
    def insert(value):
        if value > heap[0]:
            heap[0] = value
            调整堆

```


# K merge
利用最小堆完成多路有序数组的归并排序
首先每一路取一个元素生成 最小堆/最大堆，然后每次取堆顶元素替换为下一个元素，然后重新调整堆

